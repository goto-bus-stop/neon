use std::mem::MaybeUninit;
use napi_dynamic_sys::NodeApi;

pub(crate) static mut NAPI: MaybeUninit<NodeApi<'static>> = MaybeUninit::uninit();

/// Call an N-API functions.
///
/// ## Safety
/// N-API functions are unsafe to call. This macro must be used inside an unsafe block.
///
/// Code generated by this macro should not be invoked before `neon_runtime::napi::initialize` is
/// called. Doing so causes undefined behaviour.
macro_rules! napi {
    ($fun:ident, $( $args:expr ),+) => {{
        // accessible through `mod bindings`
        let napi = $crate::napi::bindings::NAPI.as_ptr();
        // accessible through `extern crate`
        let result: napi_dynamic_sys::napi_status = ((*napi).$fun)(
            $( $args ),*
        );
        result
    }};
    ($fun:ident, $( $args:expr ),+,) => {
        napi!($fun, $( $args ),* )
    };
}

pub(crate) unsafe fn load() {
    *NAPI.as_mut_ptr() = napi_dynamic_sys::from_host();
}
